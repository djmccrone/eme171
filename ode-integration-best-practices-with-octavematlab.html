<!doctype html>
<html lang="en">

<head>
  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>  ODE Integration Best Practices With Octave/Matlab | EME 171: Analysis, Simulation and Design of Mechatronic Systems
</title>
  <link rel="canonical" href="https://moorepants.github.io/eme171/ode-integration-best-practices-with-octavematlab.html">


  <link rel="stylesheet" href="https://moorepants.github.io/eme171/theme/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://moorepants.github.io/eme171/theme/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://moorepants.github.io/eme171/theme/css/pygments/emacs.min.css">
  <link rel="stylesheet" href="https://moorepants.github.io/eme171/theme/css/theme.css">

  <link rel="alternate" type="application/atom+xml" title="Full Atom Feed"
        href="https://moorepants.github.io/eme171/feeds/all.atom.xml">
  
  <meta name="description" content="This document describes some recommended best practices for integrating ordinary differential equations using Octave or Matlab. Following these guidelines will result in well organized, modular, readable code and provide advantages in computational efficiency [1]. [1]Efficiency is not the primary purpose of this document. More terse optimized code can certainly â€¦">
  <script>
    (function(i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r;
      i[r] = i[r] || function() {
        (i[r].q = i[r].q || []).push(arguments)
      }, i[r].l = 1 * new Date();
      a = s.createElement(o);
      a.async = 1;
      a.src = g;
      m = s.getElementsByTagName(o)[0];
      m.parentNode.insertBefore(a, m)
    })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
    ga('create', 'UA-15966419-8', 'auto');
    ga('send', 'pageview');
  </script>


</head>

<body>
  <header class="header">
    <div class="container">
<div class="row">
  <div class="col-sm-12">
    <h1 class="title"><a href="https://moorepants.github.io/eme171/">EME 171: Analysis, Simulation and Design of Mechatronic Systems</a></h1>
      <ul class="list-inline">
            <li class="list-inline-item"><a href="https://moorepants.github.io/eme171/">Syllabus</a></li>
            <li class="list-inline-item"><a href="https://moorepants.github.io/eme171/schedule.html">Schedule</a></li>
            <li class="list-inline-item"><a href="https://moorepants.github.io/eme171/resources.html">Resources</a></li>
      </ul>
  </div>
</div>    </div>
  </header>

  <div class="main">
    <div class="container">
      <h1>  ODE Integration Best Practices With Octave/Matlab
</h1>
      <hr>

<article class="article">
  <div class="content">
    <p>This document describes some recommended best practices for integrating
ordinary differential equations using Octave or Matlab. Following these
guidelines will result in well organized, modular, readable code and provide
advantages in computational efficiency <a class="footnote-reference" href="#id2" id="id1">[1]</a>.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Efficiency is not the primary purpose of this document. More terse
optimized code can certainly be written to maximize computation speed if
needed.</td></tr>
</tbody>
</table>
<div class="section" id="evaluating-the-odes">
<h2>Evaluating the ODEs</h2>
<p>There are several equations that are of potential interest, but the primary
equations are the ordinary differential equations, the &quot;ODEs&quot;. These equations
always have to be considered; other equations described below are optional.
Your primary goal is to solve the ODEs and discover the time dependent behavior
of the system's states. You should already have the equations in explicit first
order form before moving forward here.  &quot;Explicit&quot; refers to the fact that
there are no time derivatives on the right hand side of the equations and
&quot;first order&quot; refers to their being <span class="math">\(m\)</span> equations, one for each of the
<span class="math">\(m\)</span> state variables. The general form for these equations is:</p>
<div class="math">
\begin{equation*}
\dot{\mathbf{x}}(t) = \mathbf{f}(t, \mathbf{x}(t), \mathbf{r}(t), \mathbf{p})
\end{equation*}
</div>
<p>where</p>
<ul class="simple">
<li><span class="math">\(\mathbf{f}\)</span> is the function defining the right hand side of the
explicit first order ordinary differential equations. It defines the time
derivatives of the states at any given time, i.e. how the states change with
time.</li>
<li><span class="math">\(\mathbf{x}(t)\)</span> is the state trajectory vector which is implicitly a
function of time, size <span class="math">\(m\times1\)</span>.</li>
<li><span class="math">\(\mathbf{r}(t)\)</span> is the input trajectory vector which is implicitly a
function of time, size <span class="math">\(o\times1\)</span>.</li>
<li><span class="math">\(\mathbf{p}\)</span> is the constant parameter vector (not a function of time),
size <span class="math">\(p\times1\)</span>.</li>
</ul>
<p>Note that it is customary to drop the <span class="math">\((t)\)</span> that expresses the implicit
function of time for the various time dependent variables. That is done from
here forward.</p>
<p>The state trajectory, <span class="math">\(\mathbf{x}\)</span>, is determined by integrating
<span class="math">\(\mathbf{f}\)</span> with respect to time:</p>
<div class="math">
\begin{equation*}
\mathbf{x} = \int_{t_0}^{t_f} \mathbf{f}(t, \mathbf{x}, \mathbf{r}, \mathbf{p}) dt
\end{equation*}
</div>
<p>In general, these equations will be non-linear functions of the state variables
and there is unlikely to be analytical symbolic solutions that describe the
state trajectory in time. Thus, numerical integration is required to reach a
solution. This is fine because linear ODEs really only represent a tiny
percentage of all possible ODEs and the methods described here work with linear
and nonlinear ODEs.</p>
<p>The following describes how to numerically integrate <span class="math">\(\mathbf{f}\)</span> using
Octave or Matlab. The first step is to write an Octave/Matlab function that
evaluates <span class="math">\(\mathbf{f}\)</span>.</p>
<div class="section" id="defining-the-state-derivative-function">
<h3>Defining the State Derivative Function</h3>
<p>For example, the two explicit first order ordinary differential equations of a
simple pendulum are:</p>
<div class="math">
\begin{equation*}
\mathbf{f}
=
\begin{bmatrix}
  \dot{\theta} \\
  \dot{\omega}
\end{bmatrix}
=
\begin{bmatrix}
  \omega \\
  \frac{-mgl\sin(\theta) + \tau}{ml^2}
\end{bmatrix}
\end{equation*}
</div>
<ul class="simple">
<li>The state vector is <span class="math">\(\mathbf{x} = [\theta \quad \omega]^T\)</span>, where
<span class="math">\(\theta\)</span> is the pendulum angle and <span class="math">\(\omega\)</span> is the angular rate.</li>
<li>The parameter vector is <span class="math">\(\mathbf{p} = [m \quad l \quad g]^T\)</span>. The
variables, respectively, are mass, length, and acceleration due to gravity.</li>
<li>The input vector is <span class="math">\(\mathbf{r} = [\tau]^T\)</span>, a torque acting between
the pendulum and its static attachment (inertial space).</li>
</ul>
<p>The derivation of these equations can be found on the <a class="reference external" href="https://en.wikipedia.org/wiki/Pendulum_(mathematics)">relevant wikipedia page</a>.</p>
<p>The first step is to translate these ordinary differential equations into a
function that evaluates <span class="math">\(\mathbf{f}\)</span> at any given time instant. Below a
function named <tt class="docutils literal">eval_rhs()</tt> is defined in an m-file named <a class="reference external" href="https://moorepants.github.io/eme171/scripts/best-practices/eval_rhs.m"><tt class="docutils literal">eval_rhs.m</tt></a> that
does so. <tt class="docutils literal">rhs</tt> stands for the &quot;right hand side&quot; of the
differential equations.</p>
<p>Note that the inputs and outputs of this function are carefully documented in
the lines just below the function signature. Typing <tt class="docutils literal">help eval_rhs</tt> will
print this documentation at the Octave/Matlab command prompt.</p>
<div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span>xdot <span class="p">=</span><span class="w"> </span><span class="nf">eval_rhs</span><span class="p">(</span>t, x, r, p<span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="c">% EVAL_RHS - Returns the time derivative of the states, i.e. evaluates the</span>
     <span class="c">% right hand side of the explicit ordinary differential equations.</span>
     <span class="c">%</span>
     <span class="c">% Syntax: xdot = eval_rhs(t, x, r, p)</span>
     <span class="c">%</span>
     <span class="c">% Inputs:</span>
     <span class="c">%   t - Scalar value of time, size 1x1.</span>
     <span class="c">%   x - State vector at time t, size mx1 where m is the number of</span>
     <span class="c">%       states.</span>
     <span class="c">%   r - Input vector at time t, size ox1 were o is the number of</span>
     <span class="c">%       inputs.</span>
     <span class="c">%   p - Constant parameter vector, size px1 were p is the number of</span>
     <span class="c">%       parameters.</span>
     <span class="c">% Outputs:</span>
     <span class="c">%   xdot - Time derivative of the states at time t, size mx1.</span>

     <span class="c">% unpack the states into useful variable names</span>
     <span class="n">theta</span> <span class="p">=</span> <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
     <span class="n">omega</span> <span class="p">=</span> <span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

     <span class="c">% unpack the inputs into useful variable names</span>
     <span class="n">tau</span> <span class="p">=</span> <span class="n">r</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

     <span class="c">% unpack the parameters into useful variable names</span>
     <span class="n">m</span> <span class="p">=</span> <span class="n">p</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
     <span class="n">l</span> <span class="p">=</span> <span class="n">p</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
     <span class="n">g</span> <span class="p">=</span> <span class="n">p</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

     <span class="c">% calculate the state derivatives</span>
     <span class="n">thetadot</span> <span class="p">=</span> <span class="n">omega</span><span class="p">;</span>
     <span class="n">omegadot</span> <span class="p">=</span> <span class="p">(</span><span class="o">-</span><span class="n">m</span><span class="o">*</span><span class="n">g</span><span class="o">*</span><span class="n">l</span><span class="o">*</span><span class="nb">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">+</span> <span class="n">tau</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">l</span>^<span class="mi">2</span><span class="p">);</span>

     <span class="c">% pack the state derivatives into an mx1 vector (same order as states)</span>
     <span class="n">xdot</span> <span class="p">=</span> <span class="p">[</span><span class="n">thetadot</span><span class="p">;</span> <span class="n">omegadot</span><span class="p">];</span>

<span class="k">end</span>
</pre></div>
</div>
<div class="section" id="integrating-the-equations">
<h3>Integrating the Equations</h3>
<p>Once the function is defined, you can integrate the differential equations with
one of the available Octave/Matlab integrators or one of your own design:</p>
<div class="highlight"><pre><span></span><span class="c">%% Script that demonstrates basic integration of ODEs.</span>

<span class="c">% create time values that you desire a solution at, size 1x500</span>
<span class="c">% for example, 0 to 10 seconds with 500 equally spaced time values</span>
<span class="n">ts</span> <span class="p">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>

<span class="c">% create a vector with the initial state values, size 2x1</span>
<span class="n">theta0</span> <span class="p">=</span> <span class="mi">5</span><span class="o">*</span><span class="nb">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">;</span>  <span class="c">% angle in rad</span>
<span class="n">omega0</span> <span class="p">=</span> <span class="mf">0.0</span><span class="p">;</span>  <span class="c">% angular rate in rad/s</span>
<span class="n">x0</span> <span class="p">=</span> <span class="p">[</span><span class="n">theta0</span><span class="p">;</span> <span class="n">omega0</span><span class="p">];</span>  <span class="c">% 2x1 vector</span>

<span class="c">% create a vector to hold all the constants, be careful with units!</span>
<span class="c">% size 3x1 constant parameter vector.</span>
<span class="n">m</span> <span class="p">=</span> <span class="mf">1.00</span><span class="p">;</span>  <span class="c">% mass in kg</span>
<span class="n">l</span> <span class="p">=</span> <span class="mf">1.00</span><span class="p">;</span>  <span class="c">% length in m</span>
<span class="n">g</span> <span class="p">=</span> <span class="mf">9.81</span><span class="p">;</span>  <span class="c">% acc due to gravity in m/s^2</span>
<span class="n">p</span> <span class="p">=</span> <span class="p">[</span><span class="n">m</span><span class="p">;</span> <span class="n">l</span><span class="p">;</span> <span class="n">g</span><span class="p">];</span>  <span class="c">% 3x1 vector parameter</span>

<span class="c">% create a vector to hold all of the inputs (constant torque in this case),</span>
<span class="c">% size 1x1</span>
<span class="n">r</span> <span class="p">=</span> <span class="p">[</span><span class="mf">2.0</span><span class="p">];</span>  <span class="c">% tau, torque in N-m</span>

<span class="c">% check if the eval_rhs function works using an arbitrary time value, the</span>
<span class="c">% initial state values, and the parameters. If it doesn&#39;t you&#39;ll get an</span>
<span class="c">% error at this line or an unexpected output.</span>
<span class="n">display</span><span class="p">(</span><span class="s">&#39;Checking eval_rhs:&#39;</span><span class="p">)</span>
<span class="n">eval_rhs</span><span class="p">(</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c">% create an anonymous function with the required inputs for ode45(), i.e.</span>
<span class="c">% (t, x). Note that r and p are set to the values above on creation of this</span>
<span class="c">% function.</span>
<span class="c">% The is needed for two reasons:</span>
<span class="c">% 1. You can only store a m-file function in a variable by using anonymous</span>
<span class="c">%    functions and ode45 requires that the function be anonymous</span>
<span class="c">% 2. ode45 requires that the function only has t and x as arguments, but</span>
<span class="c">%    we&#39;d like to pass in the values of p and r from the variables declared</span>
<span class="c">%    above. This allows us to do that.</span>
<span class="c">% Point 2 above is better than using global variables to share variables in</span>
<span class="c">% all function scopes or declaring these parameters directly in the right</span>
<span class="c">% hand side function where they have limited access.</span>
<span class="n">f_anon</span> <span class="p">=</span> <span class="p">@(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="n">eval_rhs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

<span class="c">% integrate the equations with one of the available integrators, in this</span>
<span class="c">% case the Runga-Kutta 4,5 method (good for simple, non-stiff systems).</span>
<span class="p">[</span><span class="n">ts</span><span class="p">,</span> <span class="n">xs</span><span class="p">]</span> <span class="p">=</span> <span class="n">ode45</span><span class="p">(</span><span class="n">f_anon</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">x0</span><span class="p">);</span>

<span class="c">% the default output of the integrator are the times and states at each</span>
<span class="c">% desired time value:</span>
<span class="c">% - ts, size 500 x 1</span>
<span class="c">% - xs, size 500 x 2</span>

<span class="c">% plotting the states versus time should be your first check to see if the</span>
<span class="c">% result seems reasonable</span>
<span class="n">subplot</span><span class="p">(</span><span class="mi">211</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">xs</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Angle [rad]&#39;</span><span class="p">)</span>

<span class="n">subplot</span><span class="p">(</span><span class="mi">212</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">xs</span><span class="p">(:,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Angular Rate [rad]&#39;</span><span class="p">)</span>

<span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;Time [s]&#39;</span><span class="p">)</span>
</pre></div>
<div class="alert alert-warning topic">
<p class="topic-title first">Only define numbers once!</p>
<p>Note that the constant parameters are only defined in this file. This is on
purpose. If you define numerical values redundantly in multiple files and
functions you significantly increase your chances of having an erroroneous
output due to forgetting to change them all when you make edits.</p>
</div>
<p>You may be wondering what the <tt class="docutils literal">&#64;</tt> symbol specifically means. This designates
an <em>anonymous function</em> and is required by <tt class="docutils literal">ode45()</tt>. The following section
explains what an anonymous function is along with why and how it can be used.</p>
</div>
<div class="section" id="anonymous-functions">
<h3>Anonymous Functions</h3>
<p>An anonymous function was used in the above script. The <tt class="docutils literal">&#64;</tt> symbol indicates
this type of function. An anonymous function has three important features that
a normal function (written in a unique m-file) doesn't have:</p>
<ol class="arabic simple">
<li>The function can be written in a single line (in fact, if your anonymous
function is longer that a single line, 79 characters or so, you should move
functionality into a normal function m-file).</li>
<li>The function can be stored in a variable that can be passed to other
functions. For example, <tt class="docutils literal">ode45()</tt> requires that the right hand side
function be passed in as a variable.</li>
<li>Variables declared in the same scope as and before the anonymous function
will be available in the anonymous function. This allows you to avoid the
use of global variables or other bad practices at making the values
available across a set of functions and scripts.</li>
</ol>
<p>Anonymous functions are declared with the following syntax:</p>
<div class="highlight"><pre><span></span>var_name = @(arg1, arg2, arg3, ...) expression involving the args;
</pre></div>
<p>You can use anonymous functions to declare simple functions that fit on one line:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt; </span><span class="n">my_func</span> <span class="p">=</span> <span class="p">@(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
<span class="gp">&gt;&gt; </span><span class="n">my_func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">ans = 3</span>
</pre></div>
<p>use and alternative name for an existing function:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt; </span><span class="n">my_mean</span> <span class="p">=</span> <span class="p">@</span><span class="n">mean</span><span class="p">;</span>
<span class="go">my_mean = @mean</span>
<span class="gp">&gt;&gt; </span><span class="n">my_mean</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">ans =  2</span>
</pre></div>
<p>use anonymous functions to customize the input to existing functions:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt; </span><span class="n">my_func</span> <span class="p">=</span> <span class="p">@(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="n">mean</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">]);</span>
<span class="gp">&gt;&gt; </span><span class="n">my_func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">ans = 2</span>
</pre></div>
<p>and use anonymous functions to access values stored in variables in the
script's scope:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt; </span><span class="n">b</span> <span class="p">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="gp">&gt;&gt; </span><span class="n">c</span> <span class="p">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="gp">&gt;&gt; </span><span class="n">my_func</span> <span class="p">=</span> <span class="p">@(</span><span class="n">x</span><span class="p">)</span> <span class="n">mean</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">]);</span>
<span class="gp">&gt;&gt; </span><span class="n">my_func</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">ans = 2</span>
</pre></div>
<p>Note that you have to declare the variables before declaring the anonymous
function, the following code fails to compute:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt; </span><span class="n">clear</span> <span class="n">all</span><span class="p">;</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt;&gt; </span><span class="n">my_func</span> <span class="p">=</span> <span class="p">@(</span><span class="n">x</span><span class="p">)</span> <span class="n">mean</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">]);</span>
<span class="gp">&gt;&gt; </span><span class="n">my_func</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">error: &#39;b&#39; undefined near line 1 column 30</span>
<span class="go">error: called from</span>
<span class="go">    @&lt;anonymous&gt; at line 1 column 22</span>
<span class="gp">&gt;&gt; </span><span class="n">b</span> <span class="p">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="gp">&gt;&gt; </span><span class="n">c</span> <span class="p">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="gp">&gt;&gt; </span><span class="n">my_func</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">error: &#39;b&#39; undefined near line 1 column 30</span>
<span class="go">error: called from</span>
<span class="go">    @&lt;anonymous&gt; at line 1 column 22</span>
</pre></div>
<div class="alert alert-warning topic">
<p class="topic-title first">Why not global variables?</p>
<p>It is possible to use global variables to simultaneously make the constant
parameters available to both your primary script file and the file that
defines your state derivative function. This works, but it is best to avoid
global variables except for special needs. Each function provides a unique
scope where all variables defined in the function are contained in the
function. Using global variables increases the likelihood of programming
errors when programs become more complex. A google search on &quot;why global
variables are bad&quot; will provide you with background. Here is a Matlab
specific note on them:</p>
<p><a class="reference external" href="https://matlab.fandom.com/wiki/FAQ#Are_global_variables_bad.3F">https://matlab.fandom.com/wiki/FAQ#Are_global_variables_bad.3F</a></p>
</div>
<div class="alert alert-info topic">
<p class="topic-title first">Computation speed of <tt class="docutils literal">eval_rhs</tt></p>
<p>This function will be executed many times so it is important that this
function only calculates the state derivatives and does nothing else. A
simple ODE solver will evaluate the function <span class="math">\(n\)</span> times, where
<span class="math">\(n\)</span> is the number of time instances you desire a solution at. But any
quality ODE solver will execute this function more or less times than
<span class="math">\(n\)</span>.  The solvers are often adaptive and will adjust the time step
during integration to ensure low integration error. Fewer time evaluations
are needed for slowly changing trajectories and more evaluations are needed
when the trajectories change rapidly. Systems that have rapidly changing
state trajectories are referred to as &quot;stiff systems&quot; or &quot;stiff equations&quot;.
For example, a stiff system may require <span class="math">\(1000 \times n\)</span> executions for
an acceptable solution. Below, it is shown how to calculate all desired
quantities that you may be tempted to calculate in <tt class="docutils literal">eval_rhs</tt> so that you
can keep this function minimal.</p>
<p>For example, the number of right hand side function evaluations can be
obtained by turning on the <tt class="docutils literal">stats</tt> option for the integrator. Below shows
that the equations, as described above, only need to be evaluated about half
the number of desired output times.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt; </span><span class="n">x0</span> <span class="p">=</span> <span class="p">[</span><span class="mi">5</span><span class="o">*</span><span class="nb">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">;</span> <span class="mi">0</span><span class="p">];</span>
<span class="gp">&gt;&gt; </span><span class="n">ts</span> <span class="p">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>
<span class="gp">&gt;&gt; </span><span class="n">r</span> <span class="p">=</span> <span class="p">[</span><span class="mf">5.0</span><span class="p">];</span>
<span class="gp">&gt;&gt; </span><span class="n">p</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mf">9.81</span><span class="p">];</span>
<span class="gp">&gt;&gt; </span><span class="n">f_anon</span> <span class="p">=</span> <span class="p">@(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="n">eval_rhs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="gp">&gt;&gt; </span><span class="n">opt</span> <span class="p">=</span> <span class="n">odeset</span><span class="p">(</span><span class="s">&#39;stats&#39;</span><span class="p">,</span> <span class="s">&#39;on&#39;</span><span class="p">);</span>
<span class="gp">&gt;&gt; </span><span class="n">t_start</span> <span class="p">=</span> <span class="n">time</span><span class="p">();</span>
<span class="gp">&gt;&gt; </span><span class="n">solution</span> <span class="p">=</span> <span class="n">ode45</span><span class="p">(</span><span class="n">f_anon</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">opt</span><span class="p">);</span>
<span class="gp">&gt;&gt; </span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t_start</span>
<span class="go">ans = 0.050903</span>
<span class="gp">&gt;&gt; </span><span class="n">solution</span><span class="p">.</span><span class="n">stats</span><span class="p">.</span><span class="n">nfevals</span>
<span class="go">ans =  217</span>
</pre></div>
<p>But notice that if the system is stiffened, significaanly increaasing
<span class="math">\(g\)</span> does this, it now takes almost twice the number of evaluations
than the desired output times.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt; </span><span class="n">p</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1000</span><span class="p">];</span>
<span class="gp">&gt;&gt; </span><span class="n">f_anon</span> <span class="p">=</span> <span class="p">@(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="n">eval_rhs_with_input</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="p">@</span><span class="n">eval_input</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="gp">&gt;&gt; </span><span class="n">t_start</span> <span class="p">=</span> <span class="n">time</span><span class="p">();</span>
<span class="gp">&gt;&gt; </span><span class="n">solution</span> <span class="p">=</span> <span class="n">ode45</span><span class="p">(</span><span class="n">f_anon</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">opt</span><span class="p">);</span>
<span class="gp">&gt;&gt; </span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t_start</span>
<span class="go">ans = 0.35892</span>
<span class="gp">&gt;&gt; </span><span class="n">solution</span><span class="p">.</span><span class="n">stats</span><span class="p">.</span><span class="n">nfevals</span>
<span class="go">ans =  1975</span>
</pre></div>
<p>This results in the stiff system integration taking about 7 times that of
the less stiff system. If the <tt class="docutils literal">eval_rhs</tt> takes a long time to execute by
itself this can easily cause longer integration times.</p>
</div>
</div>
</div>
<div class="section" id="time-varying-inputs">
<h2>Time Varying Inputs</h2>
<p>In the above example, a constant input for the torque was used. This is
sometimes desired but in general is quite limiting. What if you want the input
to be a function of time, the state, or the parameters (which are all valid
choices)?</p>
<div class="math">
\begin{equation*}
\mathbf{r} = \mathbf{w}(t, \mathbf{x}, \mathbf{p})
\end{equation*}
</div>
<p>Similarly to the function that evaluates the differential equations, create an
Octave/Matlab function that returns the input vector given the current time,
state, and constant parameter values. Save this as <a class="reference external" href="https://moorepants.github.io/eme171/scripts/best-practices/eval_input.m"><tt class="docutils literal">eval_input.m</tt></a>.</p>
<div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span>r <span class="p">=</span><span class="w"> </span><span class="nf">eval_input</span><span class="p">(</span>t, x, p<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% EVAL_INPUT - Returns the input vector at any given time.</span>
    <span class="c">%</span>
    <span class="c">% Syntax: r = eval_input(t, x, p)</span>
    <span class="c">%</span>
    <span class="c">% Inputs:</span>
    <span class="c">%   t - A scalar value of time, size 1x1.</span>
    <span class="c">%   x - State vector at time t, size mx1 were m is the number of states.</span>
    <span class="c">%   p - Constant parameter vector, size px1 where p is the number of</span>
    <span class="c">%       parameters.</span>
    <span class="c">% Outputs:</span>
    <span class="c">%   r - Input vector at time t, size ox1 where o is the number of</span>
    <span class="c">%       inputs.</span>

    <span class="c">% NOTE : x is not needed in this case</span>

    <span class="c">% unpack the 3x1 parameter vector</span>
    <span class="n">m</span> <span class="p">=</span> <span class="n">p</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">l</span> <span class="p">=</span> <span class="n">p</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">g</span> <span class="p">=</span> <span class="n">p</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

    <span class="c">% define a sinusoidal time varying input</span>
    <span class="n">tau</span> <span class="p">=</span> <span class="n">m</span><span class="o">*</span><span class="n">g</span><span class="o">*</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="nb">sin</span><span class="p">(</span><span class="nb">pi</span><span class="o">/</span><span class="mi">20</span><span class="o">*</span><span class="n">t</span><span class="p">);</span>

    <span class="c">% pack the inputs into an 1x1 vector</span>
    <span class="n">r</span> <span class="p">=</span> <span class="p">[</span><span class="n">tau</span><span class="p">];</span>

<span class="k">end</span>
</pre></div>
<p>For this function to be useful a slight adjustment to <tt class="docutils literal">eval_rhs.m</tt> needs to
be made so that it accepts the input function instead of the values directly.
Save this as <a class="reference external" href="https://moorepants.github.io/eme171/scripts/best-practices/eval_rhs_with_input.m"><tt class="docutils literal">eval_rhs_with_input.m</tt></a>.</p>
<div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span>xdot <span class="p">=</span><span class="w"> </span><span class="nf">eval_rhs_with_input</span><span class="p">(</span>t, x, w, p<span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="c">% EVAL_RHS_WITH_INPUT - Returns the time derivative of the states, i.e.</span>
     <span class="c">% evaluates the right hand side of the explicit ordinary differential</span>
     <span class="c">% equations.</span>
     <span class="c">%</span>
     <span class="c">% Syntax: xdot = eval_rhs_with_input(t, x, w, p)</span>
     <span class="c">%</span>
     <span class="c">% Inputs:</span>
     <span class="c">%   t - Scalar value of time, size 1x1.</span>
     <span class="c">%   x - State vector at time t, size mx1 where m is the number of</span>
     <span class="c">%       states.</span>
     <span class="c">%   w - Anonymous function, w(t, x, p), that returns the input vector</span>
     <span class="c">%       at time t, size ox1 were o is the number of inputs.</span>
     <span class="c">%   p - Constant parameter vector, size px1 were p is the number of</span>
     <span class="c">%       parameters.</span>
     <span class="c">% Outputs:</span>
     <span class="c">%   xdot - Time derivative of the states at time t, size mx1.</span>

     <span class="c">% unpack the states into useful variable names</span>
     <span class="n">theta</span> <span class="p">=</span> <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
     <span class="n">omega</span> <span class="p">=</span> <span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

     <span class="c">% evaluate the input function</span>
     <span class="n">r</span> <span class="p">=</span> <span class="n">w</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

     <span class="c">% unpack the inputs into useful variable names</span>
     <span class="n">tau</span> <span class="p">=</span> <span class="n">r</span><span class="p">;</span>
     <span class="c">% if more than one input, then tau = r(1);, ...</span>

     <span class="c">% unpack the parameters into useful variable names</span>
     <span class="n">m</span> <span class="p">=</span> <span class="n">p</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
     <span class="n">l</span> <span class="p">=</span> <span class="n">p</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
     <span class="n">g</span> <span class="p">=</span> <span class="n">p</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

     <span class="c">% calculate the state derivatives</span>
     <span class="n">thetadot</span> <span class="p">=</span> <span class="n">omega</span><span class="p">;</span>
     <span class="n">omegadot</span> <span class="p">=</span> <span class="p">(</span><span class="o">-</span><span class="n">m</span><span class="o">*</span><span class="n">g</span><span class="o">*</span><span class="n">l</span><span class="o">*</span><span class="nb">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">+</span> <span class="n">tau</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">l</span>^<span class="mi">2</span><span class="p">);</span>

     <span class="c">% pack the state derivatives into an mx1 vector</span>
     <span class="n">xdot</span> <span class="p">=</span> <span class="p">[</span><span class="n">thetadot</span><span class="p">;</span> <span class="n">omegadot</span><span class="p">];</span>

<span class="k">end</span>
</pre></div>
<p>Now you can pass in the input function as an anonymous function in similar
fashion as shown earlier for <tt class="docutils literal">eval_rhs()</tt>. Save as
<a class="reference external" href="https://moorepants.github.io/eme171/scripts/best-practices/integrate_with_input_function.m"><tt class="docutils literal">integrate_with_input_function.m</tt></a>.</p>
<div class="highlight"><pre><span></span><span class="c">% this setup of initial conditions, time values, and parameters is the same</span>
<span class="c">% as before</span>
<span class="n">x0</span> <span class="p">=</span> <span class="p">[</span><span class="mi">5</span><span class="o">*</span><span class="nb">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">;</span>  <span class="c">% [rad]</span>
      <span class="mi">0</span><span class="p">];</span>        <span class="c">% [rad/s]</span>
<span class="n">ts</span> <span class="p">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>  <span class="c">% [s]</span>
<span class="n">p</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span>  <span class="c">% kg</span>
     <span class="mi">1</span><span class="p">;</span>  <span class="c">% m</span>
     <span class="mf">9.81</span><span class="p">];</span>  <span class="c">% m/s^2</span>

<span class="c">% check if the input function works for the initial condition</span>
<span class="n">display</span><span class="p">(</span><span class="s">&#39;Checking if eval_input returns an expected result:&#39;</span><span class="p">)</span>
<span class="n">eval_input</span><span class="p">(</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c">% check if the eval_rhs function works with the input function passed in as</span>
<span class="c">% an anoymous function</span>
<span class="n">display</span><span class="p">(</span><span class="s">&#39;Checking if eval_rhs_with_input returns an expected result:&#39;</span><span class="p">)</span>
<span class="n">eval_rhs_with_input</span><span class="p">(</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="p">@</span><span class="n">eval_input</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c">% create an anonymous function with the required inputs for ode45(), i.e. (t, x).</span>
<span class="n">f</span> <span class="p">=</span> <span class="p">@(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="n">eval_rhs_with_input</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="p">@</span><span class="n">eval_input</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

<span class="c">% Now the equations can be integrated.</span>
<span class="p">[</span><span class="n">ts</span><span class="p">,</span> <span class="n">xs</span><span class="p">]</span> <span class="p">=</span> <span class="n">ode45</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">x0</span><span class="p">);</span>
</pre></div>
<p>This design sets you up to easily swap out input functions. You can create an
input function for each desired input type. For example, here is a step
function, <a class="reference external" href="https://moorepants.github.io/eme171/scripts/best-practices/eval_step_input.m"><tt class="docutils literal">eval_step_input.m</tt></a>.</p>
<div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span>r <span class="p">=</span><span class="w"> </span><span class="nf">eval_step_input</span><span class="p">(</span>t, x, p<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% EVAL_STEP_INPUT - Returns the input vector at any given time.</span>
    <span class="c">%</span>
    <span class="c">% Syntax: r = eval_step_input(t, x, p)</span>
    <span class="c">%</span>
    <span class="c">% Inputs:</span>
    <span class="c">%   t - Scalar value of time, size 1x1.</span>
    <span class="c">%   x - State vector at time t, size mx1 where m is the number of</span>
    <span class="c">%       states.</span>
    <span class="c">%   p - Constant parameter vector, size px1 were p is the number of</span>
    <span class="c">%       parameters.</span>
    <span class="c">% Outputs:</span>
    <span class="c">%   r - Input vector at time t, size ox1 where o is the number of</span>
    <span class="c">%       inputs.</span>

    <span class="c">% NOTE : x and p are not used in this case</span>

    <span class="c">% calculate the step input</span>
    <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="mf">1.0</span>
        <span class="n">tau</span> <span class="p">=</span> <span class="mf">0.5</span><span class="p">;</span>  <span class="c">% [N]</span>
    <span class="k">else</span>
        <span class="n">tau</span> <span class="p">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="c">% [N]</span>
    <span class="k">end</span>

     <span class="c">% pack the input values into a ox1 vector</span>
     <span class="n">r</span> <span class="p">=</span> <span class="p">[</span><span class="n">tau</span><span class="p">];</span>

<span class="k">end</span>
</pre></div>
<p>Now integrating with the new input only requires changing the name of the
anonymous function in the main script, named here as
<a class="reference external" href="https://moorepants.github.io/eme171/scripts/best-practices/integrate_with_step_function.m"><tt class="docutils literal">integrate_with_step_function.m</tt></a>.</p>
<div class="highlight"><pre><span></span><span class="c">% intial condition, time values, and parameter setup is the same</span>
<span class="n">x0</span> <span class="p">=</span> <span class="p">[</span><span class="mi">5</span><span class="o">*</span><span class="nb">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">;</span>  <span class="c">% [rad]</span>
      <span class="mi">0</span><span class="p">];</span>        <span class="c">% [rad/s]</span>
<span class="n">ts</span> <span class="p">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>  <span class="c">% [s]</span>
<span class="n">p</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span>  <span class="c">% kg</span>
     <span class="mi">1</span><span class="p">;</span>  <span class="c">% m</span>
     <span class="mf">9.81</span><span class="p">];</span>  <span class="c">% m/s^2</span>

<span class="c">% check if the input function works for the initial condition</span>
<span class="n">display</span><span class="p">(</span><span class="s">&#39;Checking step input function:&#39;</span><span class="p">);</span>
<span class="n">eval_step_input</span><span class="p">(</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c">% check if the eval_rhs funciton works with the input function passed in as</span>
<span class="c">% an anoymous function</span>
<span class="n">display</span><span class="p">(</span><span class="s">&#39;Checking rhs input function:&#39;</span><span class="p">);</span>
<span class="n">eval_rhs_with_input</span><span class="p">(</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="p">@</span><span class="n">eval_step_input</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c">% changing the input only requires changing the function name here</span>
<span class="n">f</span> <span class="p">=</span> <span class="p">@(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="n">eval_rhs_with_input</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="p">@</span><span class="n">eval_step_input</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

<span class="c">% Now the equations can be integrated.</span>
<span class="p">[</span><span class="n">ts</span><span class="p">,</span> <span class="n">xs</span><span class="p">]</span> <span class="p">=</span> <span class="n">ode45</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">x0</span><span class="p">);</span>
</pre></div>
</div>
<div class="section" id="outputs-other-than-the-states">
<h2>Outputs Other Than The States</h2>
<p>The first type of outputs you may be interested in are functions of the states,
time, inputs, and constant parameters. It is useful to create a function that
can calculate these. It is typically best to do this after integration for both
an organizational standpoint and computational efficiency purposes (e.g. you an
leverage vectorization and broadcasting, as shown below).</p>
<div class="math">
\begin{equation*}
\mathbf{y} = \mathbf{g}(t, \mathbf{x}, \mathbf{r}, \mathbf{p})
\end{equation*}
</div>
<p>Example outputs for the pendulum might be the Cartesian coordinates of the
pendulum bob and the energy, kinetic and potential. The equations below
describe these computations:</p>
<div class="math">
\begin{align*}
x_p = l \sin(\theta) \\
y_p = l - l \cos(\theta) \\
E_k = ml^2\omega/2 \\
E_p = mghy_p
\end{align*}
</div>
<p>Create a new function file, <a class="reference external" href="https://moorepants.github.io/eme171/scripts/best-practices/eval_output.m"><tt class="docutils literal">eval_output.m</tt></a>, that encodes these mathematical
operations.</p>
<div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span>y <span class="p">=</span><span class="w"> </span><span class="nf">eval_output</span><span class="p">(</span>t, x, r, p<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% EVAL_OUTPUT - Returns the output vector at the specified time.</span>
    <span class="c">%</span>
    <span class="c">% Syntax: y = eval_output(t, x, r, p)</span>
    <span class="c">%</span>
    <span class="c">% Inputs:</span>
    <span class="c">%   t - Scalar value of time, size 1x1.</span>
    <span class="c">%   x - State vector at time t, size mx1 where m is the number of</span>
    <span class="c">%       states.</span>
    <span class="c">%   r - Input vector at time t, size ox1 where o is the number of</span>
    <span class="c">%       inputs.</span>
    <span class="c">%   p - Constant parameter vector, size px1 were p is the number of</span>
    <span class="c">%       parameters.</span>
    <span class="c">% Outputs:</span>
    <span class="c">%   y - Output vector at time t, size qx1 where q is the number of</span>
    <span class="c">%       outputs.</span>

    <span class="c">% unpacke the states</span>
    <span class="n">theta</span> <span class="p">=</span> <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">omega</span> <span class="p">=</span> <span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

    <span class="c">% unpack the parameters</span>
    <span class="n">m</span> <span class="p">=</span> <span class="n">p</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">l</span> <span class="p">=</span> <span class="n">p</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">g</span> <span class="p">=</span> <span class="n">p</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

    <span class="c">% calculate the Cartesian position of the pendulum bob</span>
    <span class="n">x_pos</span> <span class="p">=</span> <span class="n">l</span><span class="o">*</span><span class="nb">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span>
    <span class="n">y_pos</span> <span class="p">=</span> <span class="n">l</span> <span class="o">-</span> <span class="n">l</span><span class="o">*</span><span class="nb">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span>  <span class="c">% position relative to stable equilibrium</span>

    <span class="c">% calculate the kinetic and potential energies</span>
    <span class="n">kinetic_energy</span> <span class="p">=</span> <span class="n">m</span><span class="o">*</span><span class="n">l</span>^<span class="mi">2</span><span class="o">*</span><span class="n">omega</span>^<span class="mi">2</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
    <span class="n">potential_energy</span> <span class="p">=</span> <span class="n">m</span><span class="o">*</span><span class="n">g</span><span class="o">*</span><span class="n">y_pos</span><span class="p">;</span>

    <span class="c">% pack the outputs into a qx1 vector</span>
    <span class="n">y</span> <span class="p">=</span> <span class="p">[</span><span class="n">x_pos</span><span class="p">;</span> <span class="n">y_pos</span><span class="p">;</span> <span class="n">kinetic_energy</span><span class="p">;</span> <span class="n">potential_energy</span><span class="p">];</span>

<span class="k">end</span>
</pre></div>
<p>Now this function can be used after integrating the ODEs to compute any desired
outputs. The following file, <a class="reference external" href="https://moorepants.github.io/eme171/scripts/best-practices/integrate_with_output.m"><tt class="docutils literal">integrate_with_output.m</tt></a>, shows how this is done.</p>
<div class="highlight"><pre><span></span><span class="c">% same integration code as above</span>
<span class="n">x0</span> <span class="p">=</span> <span class="p">[</span><span class="mi">5</span><span class="o">*</span><span class="nb">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">;</span> <span class="mi">0</span><span class="p">];</span>
<span class="n">ts</span> <span class="p">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>
<span class="n">p</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mf">9.81</span><span class="p">];</span>
<span class="n">f_anon</span> <span class="p">=</span> <span class="p">@(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="n">eval_rhs_with_input</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="p">@</span><span class="n">eval_input</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">[</span><span class="n">ts</span><span class="p">,</span> <span class="n">xs</span><span class="p">]</span> <span class="p">=</span> <span class="n">ode45</span><span class="p">(</span><span class="n">f_anon</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">x0</span><span class="p">);</span>

<span class="c">% to compute the outputs at each time, you must iterate through time</span>
<span class="n">ys</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="nb">length</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span> <span class="mi">4</span><span class="p">);</span>  <span class="c">% create a matrix to store the values, nxq</span>
<span class="k">for</span> <span class="nb">i</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="c">% the r input isn&#39;t used, so nan can be set as a placeholder</span>
    <span class="n">ys</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span> <span class="p">:)</span> <span class="p">=</span> <span class="n">eval_output</span><span class="p">(</span><span class="n">ts</span><span class="p">(</span><span class="nb">i</span><span class="p">),</span> <span class="n">xs</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span> <span class="p">:),</span> <span class="nb">nan</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="k">end</span>
</pre></div>
<div class="alert alert-info topic">
<p class="topic-title first">Vectorizing functions</p>
<p>It is also worth noting that Octave/Matlab code can generally be written to
avoid loops, like in the above example. Slight adjustments to the output
function will allow batch calculations of the outputs, as shown below in
<a class="reference external" href="https://moorepants.github.io/eme171/scripts/best-practices/eval_output_vectorized.m"><tt class="docutils literal">eval_output_vectorized.m</tt></a>:</p>
<div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span>ys <span class="p">=</span><span class="w"> </span><span class="nf">eval_output_vectorized</span><span class="p">(</span>ts, xs, rs, p<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% EVAL_OUTPUT_VECTORIZED - Returns the output vector at the specified times.</span>
    <span class="c">%</span>
    <span class="c">% Syntax: ys = eval_output_vectorized(ts, xs, rs, p)</span>
    <span class="c">%</span>
    <span class="c">% Inputs:</span>
    <span class="c">%   ts - Scalar values of time, size nx1.</span>
    <span class="c">%   xs - State vector at each time, size nxm where m is the number of</span>
    <span class="c">%        states or mx1 if n=1.</span>
    <span class="c">%   rs - Input vector at each time, size nxo where o is the number of</span>
    <span class="c">%        inputs or ox1 if n=1.</span>
    <span class="c">%   p - Constant parameter vector, size px1 where p is the number of</span>
    <span class="c">%       parameters.</span>
    <span class="c">% Outputs:</span>
    <span class="c">%   ys - Output vector at each time, size nxq where q is the number of</span>
    <span class="c">%        outputs or qx1 if n=1.</span>

    <span class="c">% for n=1, tranpose</span>
    <span class="k">if</span> <span class="nb">length</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">xs</span> <span class="p">=</span> <span class="n">xs</span><span class="o">&#39;</span><span class="p">;</span>  <span class="c">% 1xm</span>
        <span class="n">rs</span> <span class="p">=</span> <span class="n">rs</span><span class="o">&#39;</span><span class="p">;</span>  <span class="c">% 1xo</span>
    <span class="k">end</span>

    <span class="c">% unpack the state trajectories</span>
    <span class="n">theta</span> <span class="p">=</span> <span class="n">xs</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">);</span>  <span class="c">% size n</span>
    <span class="n">omega</span> <span class="p">=</span> <span class="n">xs</span><span class="p">(:,</span> <span class="mi">2</span><span class="p">);</span>  <span class="c">% size n</span>

    <span class="c">% unpack the parameters</span>
    <span class="n">m</span> <span class="p">=</span> <span class="n">p</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">l</span> <span class="p">=</span> <span class="n">p</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">g</span> <span class="p">=</span> <span class="n">p</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

    <span class="c">% NOTE : rs is not used in this case</span>

    <span class="c">% make sure to use elementwise operators, e.g. .* instead of * for</span>
    <span class="c">% vectorized calculations</span>
    <span class="n">x_pos</span> <span class="p">=</span> <span class="n">l</span><span class="o">.*</span><span class="nb">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span>
    <span class="n">y_pos</span> <span class="p">=</span> <span class="n">l</span> <span class="o">-</span> <span class="n">l</span><span class="o">.*</span><span class="nb">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span>

    <span class="n">kinetic_energy</span> <span class="p">=</span> <span class="n">m</span><span class="o">.*</span><span class="n">l</span><span class="o">.^</span><span class="mf">2.</span><span class="o">*</span><span class="n">omega</span><span class="o">.^</span><span class="mf">2.</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
    <span class="n">potential_energy</span> <span class="p">=</span> <span class="n">m</span><span class="o">.*</span><span class="n">g</span><span class="o">.*</span><span class="n">y_pos</span><span class="p">;</span>

    <span class="c">% pack the results so the function returns a size nxq result (use commas)</span>
    <span class="n">ys</span> <span class="p">=</span> <span class="p">[</span><span class="n">x_pos</span><span class="p">,</span> <span class="n">y_pos</span><span class="p">,</span> <span class="n">kinetic_energy</span><span class="p">,</span> <span class="n">potential_energy</span><span class="p">];</span>

    <span class="c">% ensures this function returns a column vector if n=1</span>
    <span class="k">if</span> <span class="nb">length</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">ys</span> <span class="p">=</span> <span class="n">ys</span><span class="o">&#39;</span><span class="p">;</span>
    <span class="k">end</span>

<span class="k">end</span>
</pre></div>
<p>Now, instead of the for loop, you can type:</p>
<div class="highlight"><pre><span></span><span class="n">ys</span> <span class="p">=</span> <span class="n">eval_output_vectorized</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="nb">nan</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
</pre></div>
<p>These batch, or &quot;vectorized&quot;, calculations can be significantly faster than
the loops, if that is desirable.</p>
</div>
</div>
<div class="section" id="outputs-involving-state-derivatives">
<h2>Outputs Involving State Derivatives</h2>
<p>Additional outputs you may desire can also depend on the value of the time
derivative of the states, i.e. <span class="math">\(\mathbf{\dot{x}}\)</span>, and the output
function then takes this form:</p>
<div class="math">
\begin{equation*}
\mathbf{z} = \mathbf{h}(t, \dot{\mathbf{x}}, \mathbf{x}, \mathbf{r}, \mathbf{p})
\end{equation*}
</div>
<p>For example, the following function, <a class="reference external" href="https://moorepants.github.io/eme171/scripts/best-practices/eval_output_with_state_derivatives.m"><tt class="docutils literal">eval_output_with_state_derivatives.m</tt></a>,
calculates the radial and tangential acceleration of the pendulum bob. The
tangential acceleration depends on <span class="math">\(\dot{omega}\)</span>.</p>
<div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span>z <span class="p">=</span><span class="w"> </span><span class="nf">eval_output_with_state_derivatives</span><span class="p">(</span>t, xdot, x, r, p<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% EVAL_OUTPUT_WITH_STATE_DERIVATIVES - Returns the output vector at the</span>
    <span class="c">% specified time.</span>
    <span class="c">%</span>
    <span class="c">% Syntax: z = eval_output_with_state_derivatives(t, xdot, x, r, p)</span>
    <span class="c">%</span>
    <span class="c">% Inputs:</span>
    <span class="c">%   t - Scalar value of time, size 1x1.</span>
    <span class="c">%   xdot - State derivative vector as time t, size mx1 where m is the</span>
    <span class="c">%          number of states</span>
    <span class="c">%   x - State vector at time t, size mx1 where m is the number of</span>
    <span class="c">%       states.</span>
    <span class="c">%   r - Input vector at time t, size ox1 were o is the number of inputs.</span>
    <span class="c">%   p - Constant parameter vector, size px1 were p is the number of</span>
    <span class="c">%       parameters.</span>
    <span class="c">% Outputs:</span>
    <span class="c">%   z - Output vector at time t, size qx1.</span>

    <span class="c">% unpack all of the vectors</span>
    <span class="n">thetadot</span> <span class="p">=</span> <span class="n">xdot</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">omegadot</span> <span class="p">=</span> <span class="n">xdot</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

    <span class="n">theta</span> <span class="p">=</span> <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">omega</span> <span class="p">=</span> <span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

    <span class="n">m</span> <span class="p">=</span> <span class="n">p</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">l</span> <span class="p">=</span> <span class="n">p</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">g</span> <span class="p">=</span> <span class="n">p</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

    <span class="c">% calculate the radial and tangential accelerations</span>
    <span class="n">radial_acc</span> <span class="p">=</span> <span class="n">omega</span>^<span class="mi">2</span> <span class="o">*</span> <span class="n">l</span><span class="p">;</span>
    <span class="n">tangential_acc</span> <span class="p">=</span> <span class="n">omegadot</span> <span class="o">*</span> <span class="n">l</span><span class="p">;</span>

    <span class="c">% pack the result into a qx1 vector</span>
    <span class="n">z</span> <span class="p">=</span> <span class="p">[</span><span class="n">radial_acc</span><span class="p">;</span> <span class="n">tangential_acc</span><span class="p">];</span>

<span class="k">end</span>
</pre></div>
<p>The state derivatives are calculated internally when <tt class="docutils literal">ode45()</tt> is called and
are not stored during integration. These can be recalculated after integration
for use in you primary script, e.g. as in <a class="reference external" href="https://moorepants.github.io/eme171/scripts/best-practices/integrate_with_derivative_output.m"><tt class="docutils literal">integrate_with_derivative_output.m</tt></a>.</p>
<div class="highlight"><pre><span></span><span class="c">% integrate the ODEs as defined above</span>
<span class="n">x0</span> <span class="p">=</span> <span class="p">[</span><span class="mi">5</span><span class="o">*</span><span class="nb">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">;</span> <span class="mi">0</span><span class="p">];</span>
<span class="n">ts</span> <span class="p">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>
<span class="n">p</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mf">9.81</span><span class="p">];</span>
<span class="n">f_anon</span> <span class="p">=</span> <span class="p">@(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="n">eval_rhs_with_input</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="p">@</span><span class="n">eval_input</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">[</span><span class="n">ts</span><span class="p">,</span> <span class="n">xs</span><span class="p">]</span> <span class="p">=</span> <span class="n">ode45</span><span class="p">(</span><span class="n">f_anon</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">x0</span><span class="p">);</span>

<span class="c">% to compute the outputs at each time, loop through time evaluating f(t, x,</span>
<span class="c">% r, p) and then h(t, x&#39;, x, r, p)</span>
<span class="n">zs</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="nb">length</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span> <span class="mi">2</span><span class="p">);</span>  <span class="c">% place to store outputs</span>
<span class="k">for</span> <span class="nb">i</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="c">% calculate x&#39; at the given time</span>
    <span class="n">xdot</span> <span class="p">=</span> <span class="n">eval_rhs_with_input</span><span class="p">(</span><span class="n">ts</span><span class="p">(</span><span class="nb">i</span><span class="p">),</span> <span class="n">xs</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span> <span class="p">:),</span> <span class="p">@</span><span class="n">eval_input</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
    <span class="c">% calculate the outputs that depend on x&#39; and store them</span>
    <span class="n">zs</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span> <span class="p">:)</span> <span class="p">=</span> <span class="n">eval_output_with_state_derivatives</span><span class="p">(</span><span class="n">ts</span><span class="p">(</span><span class="nb">i</span><span class="p">),</span> <span class="n">xdot</span><span class="p">,</span> <span class="n">xs</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span> <span class="p">:),</span> <span class="p">@</span><span class="n">eval_input</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="k">end</span>
</pre></div>
</div>
<script type='text/javascript'>if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
  </div>
</article>


    </div>
  </div>

  <footer class="footer">
    <div class="container">
<div class="row">
  <ul class="col-sm-6 list-inline">
      <li class="list-inline-item"><a href="https://moorepants.github.io/eme171/authors.html">Authors</a></li>
    <li class="list-inline-item"><a href="https://moorepants.github.io/eme171/archives.html">Archives</a></li>
    <li class="list-inline-item"><a href="https://moorepants.github.io/eme171/categories.html">Categories</a></li>
  </ul>
  <p class="col-sm-6 text-sm-right text-muted">
    Generated by <a href="https://github.com/getpelican/pelican" target="_blank">Pelican</a>
    / <a href="https://github.com/nairobilug/pelican-alchemy" target="_blank">&#x2728;</a>
  </p>
</div>
<div class="row">
  <div class="col-sm-4 mx-auto text-center text-muted" >
    <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
      <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" />
    </a>
    <br />
    This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
  </div>
</div>    </div>
  </footer>
</body>

</html>